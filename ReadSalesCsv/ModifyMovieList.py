# writes file MovieList.html

# Unmatched file list ignores the following:
# .. any title with a / in it - don't flag multi-title items
# .. any item with 'doNotMatch' as a flag

# COL_FLAGS must be one of the following:
# ..doNotMatch - don't look for a match in Movielist.txt and don't report as an error


import os
import Output.SalesData as SalesData # file generated by ReadSalesCsv.py
import datetime
from string import punctuation
from typing import List
import re
from math import floor
import collections

FILENAME_LENGTH_LIMIT = 35 # set to 0 to disable
INPUT_FILENAME = r'.\Input\Movie List.txt'
OUTPUT_FILENAME = r'.\Output\MovieList_Sales.html'
OUTPUT_FILENAME_UNMATCHED = r'.\Output\MovieList_Unmatched.txt'
TEXT_OUTPUT_FILENAME = r'.\Output\MovieList_Sales.txt'
FIRST_DATA_LINE = 4
SALESDATA_FILENAME = r'.\SalesData.py'
OUTPUT_COLUMN_COUNT = 1

def GetElipsizedString(inString, filenameLengthLimit = 0):

	if filenameLengthLimit == 0:
		return inString

	returnVal = inString
	if len(inString) - 5 > filenameLengthLimit:
		backPad = filenameLengthLimit - floor(filenameLengthLimit * 0.2)
		frontPad = filenameLengthLimit - floor((filenameLengthLimit + 6) * 0.3)
		returnVal = f'{(inString[0:frontPad]).rstrip()}~{(inString[-1 * backPad:]).lstrip()}'

	return returnVal

def RepresentsInt(s):
    try: 
        int(s)
        return True
    except ValueError:
        return False

def MakeEntry(sales, line, matchedKeys):
	
	prefix = ''
	parts = line.split(' ')
	year = parts[len(parts) - 1]
	if len(year) == 4 and RepresentsInt(year):
		searchkey = line[:len(line) - 5].strip()  # take year off of the end of the movie name to use as the key
	else:
		searchkey = line


	if searchkey in sales.keys():
		matchedKeys.append(searchkey)
		match = sales[searchkey]
		prefix = f'{match[0]}-{GetElipsizedString(match[1], FILENAME_LENGTH_LIMIT)}'
	
	return (f'\t<td class="count">{prefix}</td><td class="description">{line}</td>',
		f'{prefix + " " if len(prefix) > 0 else str()}{GetElipsizedString(line, FILENAME_LENGTH_LIMIT)}'
	)

def CleanKeys(inDict):
	returnVal = {}
	translator = str.maketrans('', '', punctuation)

	for k in inDict.keys():
		if '/' in k: # don't strip multi-title items
			returnVal[k.lower()] = inDict[k]
		else:
			returnVal[k.translate(translator).lower()] = inDict[k]

	return returnVal

def CreateOutputTable(lines, salesDict, matchedKeys):

	lineCounter = 0

	textOutput = ''

	# html header
	output = '<html>\n'
	output += '''
	<style type="text/css">
	\t.count {font-family:monospace;font-size:8px; width:30px; border:0px;}
	\t.description {font-size:10px; border:0px; padding-right:10px;}
	\tTABLE {border:none;border-collapse:collapse;}
	\tTR {border:none;}
	</style>\n
	'''

	output += '<table cellpadding="0" cellspacing="0">\n'

	for line in lines:
		lineCounter += 1
		line = line.strip()

		if lineCounter <= FIRST_DATA_LINE:
			output += (f'\t<tr><td colspan="2" class="description">{line}</td></tr>\n')
			textOutput += f'{line}\n'
			continue

		if lineCounter == FIRST_DATA_LINE + 1:
			output += '\t<tr><td colspan="2">&nbsp;</td></tr>\n'
			output += '</table>\n'
			output += '<table cellpadding="0" cellspacing="0">\n\t<tr>\n'
			textOutput += '\n'
			continue

		entry = MakeEntry(salesDict, line, matchedKeys)
		output += f'\t{entry[0]}\n'
		textOutput += f'{entry[1]}\n'
		
		if (lineCounter + FIRST_DATA_LINE) % OUTPUT_COLUMN_COUNT == 0:
			output += '\t</tr><tr>\n'

	output += '</tr></table></html>'
	return output, lineCounter, textOutput

def CreateSeasonText(salesDict:dict, searchString:str) -> str:
	returnVal = ''
	
	sortedDict = collections.OrderedDict(sorted(salesDict.items()))
	for key in sortedDict.keys():
		if searchString not in key.lower(): continue
		returnVal += f'{sortedDict[key][0]}-{sortedDict[key][1]} {key}\n'

	return returnVal




def ReadMovieList():
	returnVal = []
	movielistDate = None

	with open(INPUT_FILENAME, 'r') as infile:
		lines = infile.readlines()

	lineCounter = 0
	for l in lines:
		lineCounter += 1

		if lineCounter == 1:
			listDateString = re.sub('[^0-9-]', '', l)
			listDateDate = datetime.datetime.strptime(listDateString, '%Y-%m-%d')
			listDateAgeDays = abs((listDateDate - datetime.datetime.now()).days)
			if listDateAgeDays > 7:
				print(f'WARNING: File {INPUT_FILENAME} is {listDateAgeDays} days old. Consider downloading a more recent version.')

		returnVal.append(l.lower())

	return returnVal

def WriteOutputFile(output, outputLineCount, textOutput):
	returnVal = True

	print(f'Found {outputLineCount} lines')

	try:
		print(f'Writing file {OUTPUT_FILENAME}')
		with open(OUTPUT_FILENAME, 'w') as outputFile:
			outputFile.write(output)
	except Exception as ex:
		print(f'Error writing output file {OUTPUT_FILENAME}. {ex}')
		returnVal = False

	try:
		print(f'Writing file {TEXT_OUTPUT_FILENAME}')
		with open(TEXT_OUTPUT_FILENAME, 'w') as outputFile:
			outputFile.write(textOutput)
	except Exception as ex:
		print(f'Error writing output file {TEXT_OUTPUT_FILENAME}. {ex}')
		returnVal = False

	return returnVal

def WriteUnmatchedFile(salesDict, matchedKeys):
	COL_COUNT = 0
	COL_AMOUNT = 1
	COL_DATES = 2
	COL_MOVIELISTKEY = 3
	COL_FLAGS = 4


	outputItems = []
	count_ignore = 0
	count_unmatched = 0
	count_season = 0
	count_doNotMatch = 0
	for k in salesDict.keys():

		if any(s in k.lower() for s in ['/', 'replacement disc']): # ignore multi-title items
			count_ignore += 1
			continue 

		if ' season ' in k.lower():
			count_season += 1
			continue

		# 2020-11-28 can't get lowercase to work
		# if 'donotmatch' in (flagName.lower() for flagName in salesDict[k][COL_FLAGS]):
		if 'doNotMatch' in salesDict[k][COL_FLAGS]:
			count_doNotMatch += 1
			continue

		if k not in matchedKeys: 
			count_unmatched += 1
			outputItems.append(f'{salesDict[k][COL_DATES]}\t{k}\n')
			
	print(f'Found {len(outputItems)} items')
	try:
		print(f'Writing file {OUTPUT_FILENAME_UNMATCHED}')
		with open(OUTPUT_FILENAME_UNMATCHED, 'w') as outputFile:
			outputFile.write(f'# generated {datetime.date.today()}\n\n')
			outputFile.write(f'# found {count_unmatched} unmatched items\n')
			outputFile.write(f'# {count_ignore} items contain ignore strings\n')
			outputFile.write(f'# ignored {count_season} "Season" items\n')
			outputFile.write(f'# ignored {count_doNotMatch} "doNotMatch" items\n')
			outputFile.write('\n')
			outputFile.writelines(outputItems)

	except Exception as ex:
		print(f'Error writing unmatched file {OUTPUT_FILENAME_UNMATCHED}')

if __name__ == "__main__":

	salesDict = CleanKeys(SalesData.sales)
	cdText = CreateSeasonText(SalesData.sales, ' cd')
	blurayText = CreateSeasonText(SalesData.sales, ' blu-ray')
	seasonText = CreateSeasonText(SalesData.sales, ' season ')

	blurayCounter = 0
	cdCounter = 0
	seasonCounter = 0
	for k in salesDict.keys():
		if ' blu-ray' in k.lower(): blurayCounter += 1
		if ' cd' in k.lower(): cdCounter += 1
		if ' season ' in k.lower(): seasonCounter += 1
	print(f'Found {blurayCounter} BLU-RAYs sold')
	print(f'Found {cdCounter} CDs sold')
	print(f'Found {seasonCounter} series sold')


	movieListLines = ReadMovieList()
	matchedKeys: List[str] = []

	outputTableResult = CreateOutputTable(movieListLines, salesDict, matchedKeys)
	output = outputTableResult[0]
	textOutput = outputTableResult[2]
	textOutput += f'\n\n=== SERIES ===\n\n{seasonText}'
	textOutput += f'\n\n=== CDs ===\n{cdText}'
	textOutput += f'\n\n=== BLU-RAYs ===\n\n{blurayText}'
	outputLineCount = outputTableResult[1]
	
	WriteOutputFile(output, outputLineCount, textOutput)
	WriteUnmatchedFile(salesDict, matchedKeys)

